<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>WebGPU Rotating Triangle</title>
    <style>
        body { margin: 0; background: #121212; display: flex; justify-content: center; align-items: center; height: 100vh; }
        canvas { width: 400px; height: 400px; }
    </style>
</head>
<body>
    <canvas id="gpuCanvas" width="800" height="800"></canvas>
    <script type="module">
        async function init() {
            if (!navigator.gpu) return;

            const adapter = await navigator.gpu.requestAdapter();
            const device = await adapter.requestDevice();
            const canvas = document.getElementById('gpuCanvas');
            const context = canvas.getContext('webgpu');
            const format = navigator.gpu.getPreferredCanvasFormat();
            context.configure({ device, format });

            // 1. Shader with a Uniform variable for rotation
            const shaderModule = device.createShaderModule({
                code: `
                    struct Uniforms {
                        angle: f32,
                    };
                    @group(0) @binding(0) var<uniform> uniforms: Uniforms;

                    @vertex
                    fn vs_main(@builtin(vertex_index) vertexIndex : u32) -> @builtin(position) vec4f {
                        var pos = array<vec2f, 3>(
                            vec2f(0.0, 0.5),
                            vec2f(-0.5, -0.5),
                            vec2f(0.5, -0.5)
                        );
                        
                        let p = pos[vertexIndex];
                        // Rotation math
                        let s = sin(uniforms.angle);
                        let c = cos(uniforms.angle);
                        let rotatedPos = vec2f(
                            p.x * c - p.y * s,
                            p.x * s + p.y * c
                        );

                        return vec4f(rotatedPos, 0.0, 1.0);
                    }

                    @fragment
                    fn fs_main() -> @location(0) vec4f {
                        return vec4f(0.0, 0.8, 1.0, 1.0);
                    }
                `
            });

            // 2. Create a Buffer for the uniform data
            const uniformBuffer = device.createBuffer({
                size: 4, // One f32 is 4 bytes
                usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,
            });

            // 3. Create a Bind Group to link the buffer to the shader
            const pipeline = device.createRenderPipeline({
                layout: 'auto',
                vertex: { module: shaderModule, entryPoint: 'vs_main' },
                fragment: { module: shaderModule, entryPoint: 'fs_main', targets: [{ format }] },
                primitive: { topology: 'triangle-list' }
            });

            const bindGroup = device.createBindGroup({
                layout: pipeline.getBindGroupLayout(0),
                entries: [{ binding: 0, resource: { buffer: uniformBuffer } }]
            });

            function frame(time) {
                // Update the angle (time is in milliseconds)
                const angle = new Float32Array([time / 1000]); 
                device.queue.writeBuffer(uniformBuffer, 0, angle);

                const commandEncoder = device.createCommandEncoder();
                const renderPass = commandEncoder.beginRenderPass({
                    colorAttachments: [{
                        view: context.getCurrentTexture().createView(),
                        clearValue: { r: 0.1, g: 0.1, b: 0.1, a: 1.0 },
                        loadOp: 'clear', storeOp: 'store'
                    }]
                });

                renderPass.setPipeline(pipeline);
                renderPass.setBindGroup(0, bindGroup); // Send the rotation data
                renderPass.draw(3);
                renderPass.end();

                device.queue.submit([commandEncoder.finish()]);
                requestAnimationFrame(frame);
            }
            requestAnimationFrame(frame);
        }
        init();
    </script>
</body>
</html>